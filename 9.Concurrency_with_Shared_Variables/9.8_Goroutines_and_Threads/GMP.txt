
GMP (Goroutine Scheduler)
    Основные компоненты:
        G (Goroutine) — легковесный поток (аналог потока ОС, но на уровне приложения).
        M (Machine) — системный поток (thread), который выполняет горутины.
        P (Processor) — логический процессор, управляющий выполнением горутин на M (будет помещать горутины (G) в Машину).

Когда Go программа запускается, ей присваивается логический процессор (P) для каждого виртуального ядра, определенного на хост-машине 
По сути, Машина — это просто системный тред. То есть, Процессор, помещая горутину в Машину, просто привязывает эту горутину к треду.

Каждому (P) назначается поток ОС (M). Этот поток по-прежнему управляется ОС, и ОС по-прежнему отвечает за размещение потока в ядре для выполнения 
Каждой программе Go также дается начальный Goroutine (G). Goroutine — аналог потока, только на уровне приложения, и они во многом похожи на потоки ОС. 
Так же, как потоки ОС включаются и выключаются ядром, контекстные программы включаются и выключаются контекстом. 


У планировщика Go есть две разные очереди выполнения: глобальная очередь выполнения (GRQ) и локальная очередь выполнения (LRQ). 
Каждому (P) присваивается LRQ (LRQ size = 256), очередь горутин, назначенных для выполнения в контексте (P) на M. GRQ предназначен для горутин, которые не были назначены для P.

Порядок выбора горутин (P) процессором:
----------------------------------------
1. Проверка LRQ.
2. 1 из 61 раза — проверка GRQ.
3. Если LRQ пуста — попытка "украсть" из LRQ другого P.
4. Если везде пусто — проверка GRQ.
5. Проверка Network Poller.

            Handoff - механизм передачи работы другой M.
                Что если горутина выполнит какую-то блокирующую операцию, например системный вызов (syscall)?
                Тогда эта горутина заблокирует нам целый тред, и ядро процессора снова будет простаивать
                
                Если тред заблокирован системным вызовом, он больше не может выполнять работу. 
                В таком состоянии он нам не особо полезен, поэтому мы просто отвяжем его от Процессора, создадим новый тред и привяжем к Процессору его. 
                
            Sysmon - Отдельный системный поток, выполняющий контроль за временем выполнения горутины
             - Проверяет долго выполняющиеся горутины (помечает stackPreempt).
             - Запускает handoff для заблокированных M.
             - Следит за сборкой мусора и другими фоновыми задачами.

                Некоторые системные вызовы короткоживущие - то есть блокируют треды на очень короткий промежуток времени. 
                Создавать для них каждый раз по отдельному треду невыгодно, поэтому сделаем такую хитрую оптимизацию:
                    Если мы знаем, что системный вызов заблокирует тред надолго, то мы сразу выполним handoff.
                    В остальных случаях мы позволим треду какое-то время оставаться в заблокированном состоянии, периодически проверяя, не освободился ли он. 
                    Если он превысит некоторый таймаут (а именно, 10ms), то также запускаем handoff

            Network Poller - часть рантайма, работающая в фоне для выполнения syscall.
                Ранее наши треды действовали так:
                    - Совершается системный вызов
                    - Тред блокируется на время ожидания ответа
                    - После получения ответа тред разблокируется
                    - Продолжение работы

                ОС обычно предоставляет механизмы, с помощью которых это ограничение можно обойти. 
                А именно, это механизмы для выполнения асинхронных системных вызовов, например: 
                                            epoll (Linux), kqueue (MacOS, BSD), IOCP (Windows).
            
                Перечисленные же выше механизмы позволяют делать так:
                    - Тред инициирует системный вызов и идёт по другим своим делам. 
                    - Системный вызов будет зарегистрирован в специальной системе, и мы сможем вернуться к нему позже.
                    - Периодически проверяем, не пришел ли ответ для системного вызова
                Горутины, ожидающие I/O, временно исключаются из очередей (P освобождается для других задач).

OS планировщик - вытесняющий    - треды не решают, сколько им находиться на ядре. Этим занимается планировщик
Go планировщик - кооперативный  - горутины сами, сколько работать. Sysmon помечает ей флаг stackguard:stackPreempt , помогая понять когда прерваться. Это Cooperative multitasking
                                    В какие именно моменты горутина понимает, что ей пора отдохнуть?
                                        - Перед вызовом функций (пролог): 
                                            Когда функция вызывается, создаётся фрейм стека (выделенная область в памяти, где хранятся локальные переменные, адрес возврата и другие данные функции). 
                                            При прерывании в момент вызова функции вся нужная информация уже сохранена во фрейме, поэтому горутину можно приостановить без риска потерять данные. 
                                            При возобновлении выполнения горутина начнёт с этого вызова функции, используя те же значения переменных.
                                        - При совершении блокирующих операций (наши любимые syscall'ы, таймеры и прочее): 
                                            в эти моменты горутина всё равно будет ждать и простаивать, поэтому пусть поработает кто-то другой
                                        - Запасной — через сигналы операционной системы, если горутина не хочет останавливаться сама
                                            ОС сигналы — это механизм уведомления процессов о каких-либо событиях на уровне ОС.



Инициализация:
--------------
1. Программа запускается:
   - Инициализируется runtime (шедулер, GC и т.д.).
   - Создается P для каждого ядра (GOMAXPROCS = NumCPU() по умолчанию).
   - Запускается начальная горутина (G) и системные потоки (M).

2. Распределение:
   - Каждому P назначается один M.
   - Если M блокируется (на syscall), P создает новый M или переключается.


Как горутины переходят из waiting в runnable?
    Горутина блокируется (например, на channel, syscall, sleep):
    → Переходит в состояние waiting (ожидание события).
    → Привязывается к объекту, который её разблокирует (например, к каналу или таймеру).
    
    Событие разблокировки (например, данные пришли в канал):
    → Runtime помечает горутину как runnable.
    → Горутина добавляется в очередь (LRQ текущего P или GRQ, если P не определён).