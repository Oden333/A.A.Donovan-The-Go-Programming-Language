Скорость получения данных с мапы - константа


Работает на хеш-функции. Она работает на нескольких принципах
1) Должна быть воспроизводима (один и тот же ключ должен выдавать одно значение)
2) Хеши 


Раньше были бакеты - контейнеры в которых лежали ключ-значение.
Брали хеш ключа. Номер бакета = Hash % кол-во бакетов
При заполнении бакета, в конце добавлялся поинтер на новый бакет...

Эвакуация: если в среднем по бакетам будет примерное заполнение 80%, то 
Коллиззии: если хеш функция для разных ключей даёт одинаковый хеш

Сейчас мапа представляет собой набор групп на 16 элементов.
Key проходит через хеш-функцию. Hash имеет 64 бита (8 байт int64)
Хеш разбивают на 2 части, h1 = 57бит и h2 = 7 бит

h2 - мета информация для быстрого поиска:
    Для каждого элемента группы образуют байт: h2 + 1 бит, говорящий о занятости ячейки

    h2 + бит заполненности = М1
    [ М1, М2, М3, ... М16 ] - последовательно лежат 16 элементов
            16 байт     
    [ М1, М2, М3, ... М16 ]
    
    Для нахождения ключа в группе, используют SIMD - single instruction, multiple data - специальная операция процессора, 
                                                   - проверяющая 16 байт на равенство входному байту за 1 раз
                                        
                                        на выходе получаем [ 0, 0, ... 1, 0, 0 ] позволяет понять есть ли ключ в группе и где лежит нужный элемент М


    Вставка:
        1) вычисляем хеш ключа, h1, h2
        2) h1 % n = номер группы
        3) нахождение дубликата по h2 
        4) линейное пробирование - вставка в первый свободный слот ( за счёт бита заполненности ) инфы о ключе и value записываем
            4.1) если свободного слота нет - идём в ближайшую группу, где есть свободный бит
            При линейном пробировании данные лежат последовательно (ранее данные могли лежать в разных местах памяти)

            Если заполненность по группам 80%+, делается ресайзинг (группы 2х + ребалансинг)

    Поиск:
        1) вычисляем хеш, h1, h2
        2) h1 % n = номер группы
        3) поиск в этой группе (simd)
        4) нашли, проверяем ключ и вытаскиваем value
            4.1) не нашли, берём следующую группу, смотрим есть ли свободный слот
                5) свободного слота нет -> идём смотрим некст группу
                5.1) свобобдный слот есть -> ключ не найден


 Основные принципы
-------------------
- Скорость доступа: O(1) в среднем случае
- Основана на хеш-функции:
  1) Детерминированность: hash(key1) == hash(key1)
  2) Равномерность: минимизация коллизий
  3) Быстрота вычисления

 Старая версия (до 1.24)
  - Бакетная система:
    * hash(key) % N → номер бакета
    * Цепочки переполнения
    * Проблемы:
      - Высокие накладные расходы при коллизиях
      - Неэффективное использование кэша CPU
      - Порог ресайзинга: ~80% заполненности

2.2. Новая версия (1.24+)
  - Групповая организация:
    * 16 элементов в группе
    * Оптимизация под cache-line (64 байта)
    * Лучшая локальность данных

 Хеш-значение:
  - 64 бита → h1(57 бит) + h2(7 бит)
  - h1 → определение группы
  - h2 → быстрый поиск внутри группы - Метаданные:
        - На группу: 16 байт (по 1 байту на элемент)
        - Структура байта (M): [h2(7) | occupied(1)]
        - Маска группы: [ M1, M2, M3 ... M16 ]

  * Поиск:
    1) Вычисление h1, h2
    2) h1 % N → номер группы
    3) Используем операцию проца SIMD - сравнение 16 байт за 1 такт
    4) Проверка найденного ключа
    5) Линейное пробирование при необходимости

  * Вставка:
    1) Аналогичный поиск
    2) Запись в первый свободный слот
    3) Линейное пробирование
    4) Ресайзинг при >80% заполненности

   Оптимизации
    - SIMD-инструкции:
      * SSE/AVX на x86
      * Одновременная проверка 16 элементов
    - Локализация данных:
      * Группы в contiguous memory
      * Минимизация cache misses
    - Эффективное управление памятью:
      * Метаданные: 16B/группа
      * Порог ресайзинга 6.5/8 элементов в группе1. Основные принципы




   key → hash(key) [64 бит]
   └── разделение:
       - h1 = hash >> 7  (57 бит, старшие биты)
       - h2 = hash & 0x7F (7 бит, младшие биты)

       